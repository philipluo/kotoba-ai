<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é¢„è§ˆç¡®è®¤ - è¨€è‘‰AI</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.4.0/dist/full.min.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .gradient-bg {
            background: linear-gradient(135deg, #fdf2f8 0%, #e0f2fe 100%);
        }
        .entry-card {
            transition: all 0.3s ease;
        }
        .entry-card:hover {
            box-shadow: 0 8px 24px rgba(0,0,0,0.12);
        }
    </style>
</head>
<body class="gradient-bg min-h-screen">
    <!-- å¯¼èˆªæ  -->
    <nav class="navbar bg-white/80 backdrop-blur-md shadow-sm sticky top-0 z-50">
        <div class="container mx-auto px-4">
            <div class="flex-1">
                <a href="../index.html" class="btn btn-ghost text-xl">
                    <span class="text-2xl">ğŸŒ¸</span>
                    <span class="font-bold">è¨€è‘‰AI</span>
                </a>
            </div>
            <div class="flex-none gap-2">
                <a href="input.html" class="btn btn-ghost btn-sm">â† è¿”å›ä¿®æ”¹</a>
                <button class="btn btn-primary btn-sm" onclick="confirmEntry()">ç¡®è®¤å…¥åº“ âœ…</button>
            </div>
        </div>
    </nav>

    <main class="container mx-auto px-4 py-8">
        <!-- æ­¥éª¤æŒ‡ç¤ºå™¨ -->
        <div class="flex justify-center mb-8">
            <ul class="steps">
                <li class="step step-primary">ç²˜è´´æ•°æ®</li>
                <li class="step step-primary">é¢„è§ˆç¡®è®¤</li>
                <li class="step" id="step3">å®Œæˆå…¥åº“</li>
            </ul>
        </div>

        <!-- æ‰¹é‡ä¿¡æ¯æç¤º -->
        <div class="alert alert-info mb-6" id="batchInfo" style="display: none;">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
            <div>
                <h3 class="font-bold">æ‰¹é‡å½•å…¥æ¨¡å¼</h3>
                <div class="text-sm">å…± <span id="totalCount" class="font-bold text-lg">0</span> æ¡æ•°æ®ç­‰å¾…å…¥åº“</div>
            </div>
        </div>

        <!-- æ•°æ®é¢„è§ˆåˆ—è¡¨ -->
        <div id="entriesList" class="space-y-6">
            <!-- åŠ¨æ€ç”Ÿæˆ -->
        </div>

        <!-- ç¡®è®¤æç¤º -->
        <div class="alert alert-warning mt-8">
            <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>
            <div>
                <h3 class="font-bold">è¯·åœ¨ç¡®è®¤å‰æ£€æŸ¥</h3>
                <div class="text-sm">ç¡®è®¤åæ‰€æœ‰æ•°æ®å°†å†™å…¥æ•°æ®åº“ã€‚å¦‚å‘ç°é”™è¯¯ï¼Œè¯·ç‚¹å‡»"è¿”å›ä¿®æ”¹"è¿›è¡Œè°ƒæ•´ã€‚</div>
            </div>
        </div>

        <!-- åº•éƒ¨æ“ä½œæ  -->
        <div class="fixed bottom-0 left-0 right-0 bg-white/90 backdrop-blur-md shadow-lg p-4 z-50">
            <div class="container mx-auto flex justify-between items-center">
                <div class="text-gray-600">
                    å…± <span id="bottomCount" class="font-bold text-primary">0</span> æ¡æ•°æ®
                </div>
                <div class="flex gap-4">
                    <a href="input.html" class="btn btn-ghost">è¿”å›ä¿®æ”¹</a>
                    <button class="btn btn-primary" onclick="confirmEntry()">
                        ç¡®è®¤å…¨éƒ¨å…¥åº“ âœ…
                    </button>
                </div>
            </div>
        </div>

        <!-- åº•éƒ¨å ä½ï¼Œé¿å…è¢«å›ºå®šæ é®æŒ¡ -->
        <div class="h-20"></div>
    </main>

    <script>
        // è¯æ€§ä¸­æ–‡æ˜ å°„
        const wordTypeMap = {
            'noun': 'åè¯',
            'verb': 'åŠ¨è¯',
            'adjective_i': 'ã„å½¢å®¹è¯',
            'adjective_na': 'ãªå½¢å®¹è¯',
            'particle': 'åŠ©è¯',
            'pronoun': 'ä»£è¯',
            'adverb': 'å‰¯è¯',
            'aux_verb': 'åŠ©åŠ¨è¯',
            'proper_noun': 'ä¸“æœ‰åè¯',
            'conjunction': 'è¿è¯',
            'interjection': 'æ„Ÿå¹è¯',
            'other': 'å…¶ä»–'
        };

        let previewData = null;

        // é¡µé¢åŠ è½½æ—¶æ˜¾ç¤ºé¢„è§ˆæ•°æ®
        document.addEventListener('DOMContentLoaded', function() {
            const data = JSON.parse(sessionStorage.getItem('previewData') || '{}');
            
            if (!data.entries || data.entries.length === 0) {
                alert('æ²¡æœ‰é¢„è§ˆæ•°æ®ï¼Œè¯·å…ˆå½•å…¥');
                window.location.href = 'input.html';
                return;
            }

            previewData = data;
            const isBatch = data.is_batch || data.total_count > 1;
            
            // æ˜¾ç¤ºæ‰¹é‡ä¿¡æ¯
            if (isBatch) {
                document.getElementById('batchInfo').style.display = 'flex';
                document.getElementById('totalCount').textContent = data.total_count;
            }
            document.getElementById('bottomCount').textContent = data.total_count;

            // æ¸²æŸ“æ‰€æœ‰æ¡ç›®
            const container = document.getElementById('entriesList');
            
            data.entries.forEach((entry, index) => {
                const card = createEntryCard(entry, index + 1, data.total_count);
                container.appendChild(card);
            });
        });

        // åˆ›å»ºå•æ¡æ•°æ®å¡ç‰‡
        function createEntryCard(entry, index, total) {
            const div = document.createElement('div');
            div.className = 'card bg-white shadow-lg entry-card';
            
            const original = entry.original_data;
            const words = entry.segmented_words || [];
            const phonetics = entry.phonetic_index || [];
            const verbs = entry.verbs_detected || [];
            
            let html = `
                <div class="card-body">
                    <div class="flex justify-between items-start mb-4">
                        <h3 class="card-title text-lg">
                            ğŸ“„ ç¬¬${index}æ¡ / å…±${total}æ¡
                        </h3>
                        <div class="flex gap-2">
                            ${entry.segmentation_source === 'ai' 
                                ? '<span class="badge badge-success">ğŸ¤– AIé¢„åˆ†è¯</span>' 
                                : '<span class="badge badge-warning">âš ï¸ è‡ªåŠ¨åˆ†è¯ï¼ˆå¯èƒ½ä¸å‡†ç¡®ï¼‰</span>'}
                            <span class="badge badge-outline">${words.length}ä¸ªè¯è¯­</span>
                        </div>
                    </div>
                    
                    <!-- åŸæ–‡å±•ç¤º -->
                    <div class="bg-gray-50 p-4 rounded-lg mb-4">
                        <p class="text-xl font-bold mb-2">${original.original_jp}</p>
                        <p class="text-gray-600 mb-1">${original.hiragana}</p>
                        ${original.romaji ? `<p class="text-gray-500 text-sm mb-2">${original.romaji}</p>` : ''}
                        <hr class="my-2">
                        <p class="text-gray-700">${original.chinese_meaning}</p>
                    </div>
            `;

            // åˆ†è¯è¡¨æ ¼
            if (words.length > 0) {
                html += `
                    <div class="overflow-x-auto mb-4">
                        <table class="table table-zebra table-sm">
                            <thead>
                                <tr>
                                    <th>ä½ç½®</th>
                                    <th>è¯è¯­</th>
                                    <th>è¯»éŸ³</th>
                                    <th>è¯æ€§</th>
                                    <th>æ„æ€</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                words.forEach(word => {
                    html += `
                        <tr>
                            <td>${word.position}</td>
                            <td class="font-bold">${word.word_jp}</td>
                            <td>${word.hiragana}</td>
                            <td><span class="badge badge-outline badge-sm">${wordTypeMap[word.word_type] || word.word_type}</span></td>
                            <td class="text-sm text-gray-600">${word.grammar_info?.meaning || ''}</td>
                        </tr>
                    `;
                });
                
                html += '</tbody></table></div>';
            }

            // åŠ¨è¯è¯†åˆ«
            if (verbs.length > 0) {
                html += '<div class="mb-4"><h4 class="font-bold text-sm text-gray-600 mb-2">ğŸ”¤ åŠ¨è¯è¯†åˆ«</h4>';
                verbs.forEach(verb => {
                    html += `
                        <div class="alert alert-info py-2">
                            <span class="text-sm">${verb.word} â†’ åŸå‹: ${verb.prototype || 'æœªçŸ¥'}, å½¢å¼: ${verb.form || 'åŸå‹'}</span>
                        </div>
                    `;
                });
                html += '</div>';
            }

            // 50éŸ³ç´¢å¼•
            if (phonetics.length > 0) {
                html += `
                    <div>
                        <h4 class="font-bold text-sm text-gray-600 mb-2">ğŸˆ³ 50éŸ³ç´¢å¼•</h4>
                        <div class="flex flex-wrap gap-1">
                            ${phonetics.map(p => `<span class="badge badge-primary badge-sm">${p}</span>`).join('')}
                        </div>
                    </div>
                `;
            }

            html += '</div>';
            div.innerHTML = html;
            return div;
        }

        // ç¡®è®¤å…¥åº“
        async function confirmEntry() {
            // æ£€æŸ¥æ˜¯å¦æœ‰ä½¿ç”¨è‡ªåŠ¨åˆ†è¯çš„æ•°æ®
            const autoSegmentedCount = previewData.entries.filter(e => e.segmentation_source === 'auto').length;
            let confirmMsg = `ç¡®è®¤è¦å°†è¿™${previewData.total_count}æ¡æ•°æ®å…¨éƒ¨å…¥åº“å—ï¼Ÿ`;
            
            if (autoSegmentedCount > 0) {
                confirmMsg = `âš ï¸ è­¦å‘Šï¼šå…¶ä¸­æœ‰ ${autoSegmentedCount} æ¡æ•°æ®ä½¿ç”¨äº†è‡ªåŠ¨åˆ†è¯ï¼ˆå¯èƒ½ä¸å‡†ç¡®ï¼‰ã€‚\n\n` +
                           `å»ºè®®å…ˆè¿”å›ä¿®æ”¹ï¼Œä½¿ç”¨AIé¢„åˆ†è¯ä»¥è·å¾—æ›´å‡†ç¡®çš„ç»“æœã€‚\n\n` +
                           `ç¡®è®¤ä»è¦ç»§ç»­å…¥åº“å—ï¼Ÿ`;
            }
            
            if (!confirm(confirmMsg)) {
                return;
            }

            try {
                const response = await fetch(`/api/entries/${previewData.preview_id}/confirm`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        entries: previewData.entries
                    })
                });

                const result = await response.json();

                if (result.success) {
                    alert(`âœ… æˆåŠŸå…¥åº“${result.data.total_entries}æ¡æ•°æ®ï¼`);
                    sessionStorage.removeItem('previewData');
                    window.location.href = '../index.html';
                } else {
                    alert('å…¥åº“å¤±è´¥: ' + (result.error?.message || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (error) {
                console.error('è¯·æ±‚å¤±è´¥:', error);
                alert('è¯·æ±‚å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
            }
        }
    </script>
</body>
</html>